# 简介

记录必要的数论理论和证明过程

**请使用 typora 打开**

# 取模运算

$$
a\ mod\ b = a - \lfloor \frac{a}{b} \rfloor ,取模运算转换 \\
a \equiv b (mod\ m) 同余表达在模数 m 代数系统下二者等价
$$



## 运算律

$$
 (a + b)\ mod\ p = (a\ mod\ p + b\ mod\ p)\ mod\ p \\
  (a \times b)\ mod\ p = (a\ mod\ p \times b\ mod\ p)\ mod\ p \\
   (a ^ b)\ mod\ p = ((a\ mod\ p) ^{b\ mod\ p})\ mod\ p \\
$$



# 扩展欧几里得算法

欧几里得算法也就是俗称的辗转相除法，在了解扩展欧几里得算法前，先要了解裴蜀定理

$$
对于任意正整数对 a,b 必定存在一对整数 x,y 使得 ax + by = gcd(a,b)
$$


> 此外对于任意的 a*x + b*y 的形式，其也只能组合出 gcd(a,b) 的倍数

显然，x 和 y 不止一种配对，而扩展欧几里得算法则可以求其中一个特解。算法原理：

$$
对于 gcd(a,b) 当 b = 0 时，x = 1 , y = 0 就是一组解 \\
对于都非零的状态有 gcd(a,b) = gcd(b,a\ mod\ b) 将后者展开有 \\
gcd(b,a\ mod\ b) \\
			   = bx + (a\ mod\ b) y \\
               = b*x + (a-\lfloor \frac{a}{b}\rfloor b)y \\
               = y*a + (x - \lfloor \frac{a}{b}\rfloor y)*b \\
由此，我们构造出了递归求解 x 和 y 的方法，即 \\
x^` = y \\
y^` = x - [a/b]*y \\
$$


# 乘法逆元

对于自然数域，加法减法乘法对取模运算都满足取模运算的递推规律（不知道运算律的名字），如

$$
a\ mod\ m + b\ mod\ m \equiv a+b(mod\ m)
$$


而乘法，阶乘分别都是二阶加法和三阶加法，因此也满足这样的规律
除法是独立的运算逻辑，不满足这样的规律，因此需要把除法运算转变成乘法运算
使得在取模意义下的代数系统本质上只有加法

对一个数找到另一个数，使得乘以这个数和除以原来的数在取模意义下能够达到同样的效果
这个数就叫做原数在模数意义下的乘法逆元

例如，对于 3 而言，5 就是其在模 7 意义下的逆元，例如 6 / 3 % 7 = 2 ,而 6 * 5 % 7 = 2 答案一致
（注意取模代数系统中没有分数，即只有整除意义下逆元才有意义）

乘法逆元可以记作

$$
a*b \equiv 1(mod\ p)
$$


其中 a 与 b 互为模 p 意义下的逆元

## 逆元的意义

对于逆元，还有另外一个性质，那就是对于一个数，其逆元和该数取模后的数的逆元是相等的（证明很简单） ，例如 3 在模 7 意义下的
逆元是 5，而 10 17 的逆元也都可以是五 （逆元有很多）。根据这个性质，对于一个非常大的除数，我们可以先对其取模
然后求其逆元，从而达到同样的除法效果

这个非常大的除数是远远超于计算机表达的，因此这个除数在构造的时候就已经被不断的取模运算了
也就是我们最终也只能获得这个大数的取模结果

对于巨大的被除数，我们也只能获得模取结果，而模取结果无论除数还是被除数都无法参与运算，此时逆元就更显重要

## 如何求逆元

这里有一个条件是，**当且仅当除数 b 与模数 m 互质的时候，b 才有逆元**，满足这个的前提下

+ 当 m 为质数时，此时仅 m 的倍数没有逆元，且逆元为 **b^(m-2)** (可以用费马小定理证明) 
+ 对于任意一对互质的正整数 a,b，可以通过扩展欧几里得算法求得 a*x + b*y = gcd(a,b) 其中 x 就是 a 模 b 意义下的逆元，y 就是 b 模 a 意义下的逆元

# 中国剩余定理 CRT

中国剩余定理用于求解一个线性同余方程组
$$
\left\{
\begin{matrix}
 x \equiv a_1 (mod\ m_1) \\
 x \equiv a_2 (mod\ m_2) \\
 x \equiv a_3 (mod\ m_3) \\
 ......\\
 x \equiv a_n (mod\ m_n) \\
\end{matrix}
\right.
$$
其中 $m_i$ 两两互质，则解有公式
$$
N = \prod_{i=1}^{n}m_i\\
M_i = \frac{N}{m_i}
x = \sum_{i=1}^{n}a_iM_iM_i^{-1} \ ,M^{-1} 表达模数乘法逆元
$$

## 扩展

对于模数非两两互质的方程组，如何求解？
$$
\because  x \equiv a_i (mod\ m_i) , x \equiv a_j (mod\ m_j)\\
\therefore x = k_ia_i+m_i , x = k_ja_j + m_j \\
k_ia_i-k_ja_j = m_j - m_i\\
则有通解\\
\left\{
\begin{matrix}
k_i=k_i^` + k\frac{a_j}{gcd(a_i,a_j)} \\
k_i=k_j^` + k\frac{a_i}{gcd(a_i,a_j)} \\
\end{matrix}
\right.\\
其中 k_i^`k_j^`为一对特解\\
由裴蜀定理可得，当且仅当 m_j-m_i | gcd(a_i,a_j)时，k_i,k_j 有解，设其有解，则令\\
na_i+ma_j = gcd(a_i,a_j),k_i^` = \frac{mj-mi}{gcd(a_i,a_j)}n,k_j^` = \frac{mi-mj}{gcd(a_i,a_j)}m\\
带入 k_i 得 x = k_i^`a_i + k\frac{a_j}{gcd(a_i,a_j)}a_i + m_i = lcm(a_i,a_j)k + k_i^`a_i + m_i\\
则得到 x 得新解系，即将两个方程合并成一个方程，由此依次合并所有方程可得最终得解系
$$

# 卡特兰数

卡特兰数是一类问题的数学公式解，例如求定长括号序列的可能方案数，这里就以此为例理解卡特兰数模型

我们从零开始，假象一个 $2n\times 2n$ 的网格，初始状态下我们在原点。将“添加一个左括号”定义为“向右走一步”，将“添加一个右括号”定义为“向上走一步”，那么，假设问题是“对于一个 2*n 长的括号序列有多少种”，就相当于“从原点到 (n,n)”的合法路径有多少条

如何定义合法路径？我们知道，一个括号序列，其任意一个前缀中，右括号的数量不能多于左括号，这就等价于“路径行进的过程中，向上走不能比向右走多”，更等价于“路径中不能出现 $(x+1,x)$这样的点”。由此，我们成功定义出了合法路径和非法路径的区别

从圆点到$(n,n)$的路径总数为$C_{2n}^n$（我们走了2n步，选择其中n步向上走），而对于非法路径的总数为$C_{2n}^{n+1}$，如何推导？

对于任意一个非法路径，我们将其以第一个$(x+1,x)$的点为依据，将后续的路径对$y=x+1$反转，我们就得到了一条终于$(n-1,n+1)$的路径，显然，对于任何一条非法路径，我们都可以如此构造。最后一个问题是，这二者是否是双射的呢？这其实并不难证明，这里就略过了。总之，根据上述总结，我们推出了非法路径的数量就是从原点到$(n-1,n+1)$的路径总数，也就是$C_{2n}^{n+1}$，则有
$$
f(n) = C^{n}_{2n} - C^{n+1}_{2n}=\frac{C^{n}_{2n}}{n+1}
$$
最后的公式具有数学意义，可以简化计算量。记住前面一个就好，比较好记，后面那个好推
