package model;

import java.util.Arrays;

/**
 * <h1>acwing 240 题</h1>
 * <p>
 * 动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。
 * <p>
 * A 吃 B，B 吃 C，C 吃 A。
 * <p>
 * 现有 N 个动物，以 1∼N 编号。
 * <p>
 * 每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。
 * <p>
 * 有人用两种说法对这 N 个动物所构成的食物链关系进行描述：
 * <p>
 * 第一种说法是 1 X Y，表示 X 和 Y 是同类。
 * <p>
 * 第二种说法是 2 X Y，表示 X 吃 Y。
 * <p>
 * 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。
 * <p>
 * 当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
 * <p>
 * 当前的话与前面的某些真的话冲突，就是假话；
 * <ul>
 *     <li>当前的话与前面的某些真的话冲突，就是假话</li>
 *     <li>当前的话中 X 或 Y 比 N 大，就是假话</li>
 *     <li>当前的话表示 X 吃 X，就是假话</li>
 * </ul>
 * <p>
 * <p>
 * <p>
 * 你的任务是根据给定的 N 和 K 句话，输出假话的总数。
 *
 * <h1>解题思路</h1>
 * <p>
 * 拓展于并查集的模型，并查集中的一个集合表达的是”一个推理域“，所谓推理域是指在这个集合中的元素关系都是已知并且可以相互推导的
 * 除了基本的 parent 数组来存储树结构，我们还需要一个 relation 数组来存储节点和父节点之间的关系
 * 推理域之间的合并，只需要找出两个根节点之间的关系，就足够进一步推理出所有两个推理域之内所有节点的关系
 * <p>
 * 路径压缩在这个模型内的含义也略有变化，除了基本的将节点变成根节点的直接子节点之外，还需要根据已有的其与父节点之间的关系，层层
 * 推理出其与根节点直接的关系，从而更新成当前与父节点之间的关系
 * <p>
 * 该模型只能用于环状结构的推理模型，在本题中，是最简单的环状结构，任意两点之间的关系可以被定义为 同类，吃，被吃
 * 但是对于更多元的环状结构，例如四元，就很难用语言定义语义化含义了，
 * 因此应该改变关系定义，抽象成两点之间的距离（注意是有向图），即，<b>节点元素在关系图中与父节点的最短路长度</b>
 * <p>
 * 则，若关系图为k元环形图，则有 k 种关系，分别以编号 x 为 0 到 k - 1 标记，表达任意两点在关系图中的最短路长为 x 。
 * 则有关系 a x b && b x c == a (x+y)%k c
 */
public class FoodChains {

    static int[] p;
    static int[] r;
    static final int k = 3; // 本题的关系图是三元推理图

    static void init(int n) {
        p = new int[n];
        Arrays.fill(p, -1);
        r = new int[n]; // 根节点的父节点看作是根节点自己
    }

    static int find(int x) {
        if (p[x] == -1) return x;
        int t = p[x];
        p[x] = find(p[x]);
        r[x] = (r[x] + r[t]) % k; // r[x] 是当前节点与父节点的关系，r[t] 在递归后表达了父节点与根节点的关系
        return p[x];
    }

    // x 与 y 之间的关系为 k，从而可以推理出两个集合根节点之间的关系，从而合并推理域
    static void union(int x,int y,int relate){
        int px = find(x);
        int py = find(y);
        // 已经确定的关系自然不必再确定
        if (px != py) {
            r[px] = (r[y] - r[x] + relate + k) % k; // 推测 px 与 py 之间的关系
            p[px] = py;
        }
    }

    // 判断两个元素之间的关系是否已经确定
    static boolean connect(int x,int y){
        return find(x) == find(y);
    }

    // 判断两个元素之间的关系是不是 relate
    // 如果不能确定就返回 false
    static boolean check(int x,int y,int relate){
        return connect(x,y) && (r[x] - r[y] + k) % k == relate;
    }
}
